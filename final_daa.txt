// a. Implement Factorial of a number.

#include <stdio.h> 
int main()
{
int n, i;
unsigned long long factorial = 1; 
printf("Enter an integer: "); 
scanf("%d",&n);
if (n < 0)
printf("Error! Factorial of a negative number doesn't exist.");
    else
{
for(i=1; i<=n; ++i)
{
factorial *= i;	
}
printf("Factorial of %d = %llu", n, factorial);
}
return 0;
}














//b. Finding max element 
#include <stdio.h> 
int main()
{
int i, n;
float arr[100];
printf("Enter total number of elements(1 to 100): "); scanf("%d", &n);
printf("\n");
for(i = 0; i < n; ++i)
{
printf("Enter Number %d: ", i+1); scanf("%f", &arr[i]);
}
for(i = 1; i < n; ++i)
{
if(arr[0] < arr[i])
arr[0] = arr[i];
}
printf("Largest element = %.2f", arr[0]); return 0;
}










//c. linear search/sequential search
#include<stdio.h> 
int main()
{
int array[100], search, c, number;
printf("Enter the number of elements in array\n"); 
scanf("%d",&number);
printf("Enter %d numbers\n", number); 
for ( c = 0 ; c < number ; c++ ) 
{
        printf("Enter the %d element : ",c+1);
    scanf("%d",&array[c]);
 }
printf("Enter the number to search\n"); 
scanf("%d",&search);
for ( c = 0 ; c < number ; c++ )
{
if ( array[c] == search ) 
{
printf("%d is present at location %d.\n", search, c+1); 
break;
}
}
if ( c == number )
printf("%d is not present in array.\n", search); 
return 0;
}











// a.   Factorial of a number using recursion
#include <stdio.h>
int factorial(int);
int main()
{
          int num,result; 
     printf("Enter a number to find it's Factorial: ");    
                                                                                                                 scanf("%d", &num);
       if (num < 0)
      {
        printf("Factorial of negative number not possible\n");
      }
      else
     {
        result = factorial(num);
        printf("The Factorial of %d is %d.\n", num, result);
     }
return 0;
}
int factorial(int num)
{
if (num == 0 || num == 1)
{
return 1;
}
else
{
return(num * factorial(num - 1));
}
}
























//b.Find gcd of two numbers using euclids algorithm
               
               #include <stdio.h>             
       int gcd(int a, int b)
{
if (b == 0) return a;
return gcd(b, a % b);
}

int main()
{
int a ,b;
printf("Enter the value of a and b\n");
scanf("%d %d",&a,&b);
printf("GCD of %d and %d is %d ", a, b, gcd(a, b)); return 0;
}













//c.Tower of Hanoi


#include <stdio.h>
#include <stdlib.h>

void hanoi(int n, char rodFrom, char rodMiddle, char rodTo)
{
    if(n==1)
   {
        printf("Disk 1 moved from %c to %c \n",rodFrom,rodTo);
        return;
    }
    hanoi(n-1,rodFrom,rodTo,rodMiddle);

    printf("Disk %d moved from %c to %c \n",n,rodFrom,rodTo);
    hanoi(n-1,rodMiddle,rodFrom,rodTo);
 
}
 int main()
{
    int n;
    printf("enter total number of disc\n");
    scanf("%d",&n);
    hanoi(n, 'A', 'B', 'C');
    return 0;
}




















//==> bubblesort
#include<stdio.h>
int main()
{
    int array[100], n, i, j, temp; 
    printf("Enter number of elements\n");
    scanf("%d", &n); 
    printf("Enter %d Numbers:\n", n); 
    for(i = 0; i < n; i++)
        scanf("%d", &array[i]); 
    for(i = 0 ; i < n - 1; i++)
    {
        for(j = 0 ; j < n-i-1; j++)
        {
            if(array[j] > array[j+1]) 
            {
                temp=array[j];
                array[j]=array[j+1];
                array[j+1]=temp;
            }
        }
    } 

    printf("Sorted Array:\n"); 
    for(i = 0; i < n; i++)
        printf("%d\t", array[i]);
    return 0;
}
















// ==> merge sort

#include<stdio.h> 
#include<time.h>
#define MAX 50
void mergeSort(int arr[],int low,int mid,int high); 
void partition(int arr[],int low,int high);
double tc;
time_t start,end;
void main()
{
    int a[MAX],i,n;
    printf("Enter the total number of elements: "); 
    scanf("%d",&n);
    printf("Enter the elements to be sorted:\n\n");
    for(i=0;i<n;i++)
    {
        printf("Enter the %d element:",i+1);
        scanf("%d",&a[i]);
        printf("\n");
    }
            start=clock();
    partition(a,0,n-1);
            end=clock();
    printf("After merge sorting elements are: "); 
    for(i=0;i<n;i++)
    {
        printf("%d ",a[i]);
    }
            tc=difftime(end,start)/CLOCKS_PER_SEC;
    printf("time efficiency is %lf",tc);
}

void partition(int arr[],int low,int high)
{
    int mid; 
    if(low<high)
    {
        mid=(low+high)/2; 
        partition(arr,low,mid); 
        partition(arr,mid+1,high); 
        mergeSort(arr,low,mid,high);
    }
}

void mergeSort(int arr[],int low,int mid,int high)
{ 
    int i,m,k,l,temp[MAX];
    l=low; i=low; m=mid+1;
    while((l<=mid)&&(m<=high))
   { 
        if(arr[l]<=arr[m])
       
                      {
            temp[i]=arr[l]; 
            l++;
        }
        
else
        {
            temp[i]=arr[m]; 
            m++;
        }
            i++;
    }
    if(l>mid)
    {
        for(k=m;k<=high;k++)
        { 
            temp[i]=arr[k];
            i++;
        }
    }
    else
    {
        for(k=l;k<=mid;k++)
        { 
            temp[i]=arr[k];
            i++;
        }
    }
    for(k=low;k<=high;k++)
    { 
        arr[k]=temp[k];
    }
}

















// ==> quick sort
#include<stdio.h> 
# include<time.h>
#define max 500
double tc;
time_t start,end;
void qsort(int [],int,int); 
int partition(int [],int,int); 
int main()
{
    int a[max],i,n;
    printf("Enter the total number of elements: "); 
    scanf("%d",&n);
    printf("Enter the elements to be sorted:\n\n");
    for(i=0;i<n;i++)
    {
        printf("Enter the %d element:",i+1);
        scanf("%d",&a[i]);
        printf("\n");
    }

    printf("\nThe array elements before\n"); 
    for(i=0;i<n;i++)
        printf("%d\t",a[i]);
                start=clock();
    qsort(a,0,n-1);
                end=clock();
    printf("\nElements of the array after sorting are:\n"); 
    for(i=0;i<n;i++)
        printf("%d\t",a[i]);
               tc=difftime(end,start)/CLOCKS_PER_SEC;
    printf("time efficiency is %lf",tc);
}

void qsort(int a[],int low,int high)
{
    int j; if(low<high)
    {
        j=partition(a,low,high); 
        qsort(a,low,j-1); 
        qsort(a,j+1,high);
    }
}

int partition(int a[], int low,int high)
{
    int pivot,i,j,temp; pivot=a[low]; i=low+1;
    j=high; 
    while(1)
    {
        while(pivot>a[i] && i<=high) 
        i++;
        while(pivot<a[j])
        j--;
        if(i<j)
        {
            temp=a[i]; 
            a[i]=a[j]; 
            a[j]=temp;
        }
        else
        {
            temp=a[j]; 
            a[j]=a[low]; 
            a[low]=temp;
         return j;
        }
               }
}

















//==> insertion sort
#include <math.h>
#include <stdio.h>
#include<time.h>
 
void insertionSort(int arr[], int n)
{
    int i, key, j;
    for (i = 1; i < n; i++) 
    {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) 
        {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
int main()
{
    int arr[20],n,i;
    clock_t  start, end;
    double total;
    printf("enter array size<20\n");
    scanf("%d",&n);
    printf("enter array elements\n");
    for(i=0;i<n;i++)
    scanf("%d",&arr[i]);
    start = clock();
    insertionSort(arr, n);
    end = clock();
    total = (double)(end-start)/CLOCKS_PER_SEC;
    printf("array after sorting is\n");
    for (i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
    printf("time taken=%f",total);
    return 0;
}















//==> floyds algorithm
#include<stdio.h>
#include<time.h>
clock_t  start, end, total; 
int min(int,int);
void floyds(int p[10][10],int n)
{
int i,j,k; 
    for(k=1;k<=n;k++) 
        for(i=1;i<=n;i++) 
            for(j=1;j<=n;j++)
                if(i==j) 
                    p[i][j]=0; 
                else
                p[i][j]=min(p[i][j],p[i][k]+p[k][j]);
}

int min(int a,int b)
{
if(a<b) return(a); else return(b);
}

void main()
{
    int p[10][10],w,n,e,u,v,i,j;
    printf("\n Enter the number of vertices:"); 
    scanf("%d",&n);
    printf("\n Enter the number of edges:\n"); 
    scanf("%d",&e);
    for(i=1;i<=n;i++)
        {
        for(j=1;j<=n;j++)
            p[i][j]=999;
        }
    for(i=1;i<=e;i++)
    {
        printf("\n Enter the end vertices of edge%d with its weight \n",i); 
        scanf("%d%d%d",&u,&v,&w);
        p[u][v]=w;
    }
printf("\n Matrix of input data:\n");

for(i=1;i<=n;i++)
{
    for(j=1;j<=n;j++) 
        printf("%d\t",p[i][j]); 
        printf("\n");
}
start=clock();
floyds(p,n);
end=clock();
printf("\n Transitive closure:\n"); 
for(i=1;i<=n;i++)
{
    for(j=1;j<=n;j++) 
        printf("%d\t",p[i][j]); 
        printf("\n");
}
printf("\n The shortest paths are:\n"); 
for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
    {
        if(i!=j)
        printf("\n <%d,%d>=%d",i,j,p[i][j]);
    }
total = (end-start)/CLOCKS_PER_SEC;
printf("\ntime taken=%f\n",total);
}
























/*Implement N Queen's problem using Back Tracking.*/
#include<stdio.h> 
#include<time.h> 
#include<math.h>
#include<stdlib.h>
const int max=20;
clock_t  start, end, total; 
int  place(int x[],int k)
{
int i; 
for(i=0;i<k;i++)
    if (x[i]==x[k] || abs(x[i]-x[k])==abs(i-k)) 
    return 0;
return 1;

}
void display(int x[], int n)
{
    char chessb[max][max]; 
    int i,j;
    for(i=0;i<n;i++) 
        for(j=0;j<n;j++)
            chessb[i][j]='x';
    for(i=0;i<n;i++)
        chessb[i][x[i]]='q';

    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
            printf("%c", chessb[i][j]);

        printf ("\n");
    }

    printf ("\n");

}


void nqueens(int n)
{
    int x[max]; 
    int k; 
    x[0]=-1; 
    k=0;
    while(k>=0)
    {
        x[k]=x[k]+1;
        while(x[k]<n && !place(x,k)) 
            x[k]=x[k]+1;
        if(x[k]<n)
            if (k==n-1)
                display(x,n); 
            else
            {
                k++; x[k]=-1;
            }
        else
        k--;
    }
}

void main()
{
int n;
printf("enter the no of queens\n"); 
scanf("%d", &n);
printf("the soln to %d queens problem is \n", n);
start=clock();
nqueens(n);
end=clock();
total = (end-start)/CLOCKS_PER_SEC;
printf("\ntime taken=%f\n",total);
}

























//Kruskal’s algorithm
#include<stdio.h>
int i,j,k,a,b,v,u,n,ne=1;
int min,mincost=0,cost[9][9],parent[9]; 
void main()
{
printf("\nEnter the number of vertices\n"); 
scanf("%d",&n);
printf("Enter the adjacency matrix::\n"); 
for (i=1;i<=n;i++)
for (j=1;j<=n;j++)
{
scanf("%d",&cost[i][j]); 
if(cost[i][j]==0)
cost[i][j]=999;
}
printf("\nThe edges of spanning treeare:\n\n"); 
while(ne<n)
{
for (i=1,min=999;i<=n;i++) 
for (j=1;j<=n;j++)
{
 if(cost[i][j]<min)
{
min=cost[i][j];
a=u=i; b=v=j;
}
}
while(parent[u]) 
u=parent[u]; 
while(parent[v]) 
v=parent[v]; 
if(u!=v)
{
printf("\n%d\tEdge(%d,%d)=%d",ne++,a,b,min); 
mincost+=min;
parent[v]=u;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n\tMiINCOST=%d\n",mincost);
}


















//b) USING PRIM'S ALGORITHM

#include<stdio.h>
int i, j, a, b, v, u,n, ne=1;
int min,mincost=0, cost[9][9], visited[9]; 
void main()
{
printf( "The no of vertices=\t"); 
scanf("%d",&n);
printf("Enter the adjacency matrix=\t"); 
for( i=1;i<=n;i++)
for( j=1;j<=n;j++)
{
scanf("%d",&cost[i][j]);
if(cost[i][j]==0) 
cost[i][j]=999;
}
printf("The edges of spanning tree are \t");
visited[1]=1; 
while(ne<n)
{
for(i=1,min=999;i<=n; i++)
{
for(j=1;j<=n;j++)
{
if(cost[i][j]<min)
{
if(visited[i]==0) 
continue;
else
{
min=cost[i][j]; 
a=u=i;
b=v=j;
}
}
}
}
if(visited[v]==0)
{
printf("\n%d\t Edge \t(%d, %d)=%d\n",ne++, a, b, min); 
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n\t mincost=%d\n",mincost);
}